using UnityEngine;
using SignalProcessing;
using System;
using EventType = SignalProcessing.EventType;

#pragma warning disable 649
public class AutoFilter : MonoBehaviour
{
    public event Action<SliderEvent> FilterOutputHandler;

    [SerializeField]
    private uint epsilon, deadzone;

    [SerializeField]
    private FrequencyType type;

    [SerializeField, Tooltip("After this amount of type without a value provided, will generate a value")]
    private double period;

    private Filter filter;

    private (uint? value, double time) last;

    private double currentTime =>
        SignalProcessing.Utils.GetCurrentTime(type);

    private void Start()
    {
        filter = new Filter(epsilon, deadzone);
        FilterOutputHandler += DefaultHandler;
        Provide(null);
    }

    private void DefaultHandler(SliderEvent e)
    { }

    public void Provide(uint? value)
    {
        uint? output = PushToFilter(value);
        SliderEvent e = new SliderEvent(GetTypeFor(last.value, output), output);
        last = (output, currentTime);
        FilterOutputHandler(e);
    }

    private void Generate()
    {
        last.time = currentTime;
        var value = PushToFilter(last.value);
        if (value != last.value)
        {
            last.value = value;
            FilterOutputHandler(new SliderEvent(GetTypeFor(last.value, value), value, autoGenerated: true));
        }
    }

    private void Update()
    {
        if (currentTime - last.time >= period)
        {
            Generate();
        }
    }

    private uint? PushToFilter(uint? value)
    {
        var filtered = filter.Push(value ?? 0);
        return filtered <= deadzone || !value.HasValue ? null : filtered;
    }

    private static EventType GetTypeFor(uint? last, uint? current)
    {
        if (last.HasValue == current.HasValue)
        {
            return current.HasValue ? EventType.Touching : EventType.NoTouches;
        }
        return current.HasValue ? EventType.FingerDown : EventType.FingerUp;
    }
}