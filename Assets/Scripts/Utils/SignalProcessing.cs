using System;
using System.Collections.Generic;
using Utils.SystemExtensions;
using UnityEngine;
using System.Text;

namespace Utils
{
    namespace SignalProcessing
    {
        [Serializable]
        public enum FrequencyType
        {
            Frames,
            Seconds,
        }

        [Serializable]
        public enum EventType
        {
            FingerUp,
            FingerDown,
            Touching,
            NoTouches,
        }

        public readonly struct FilterEventData
        {
            public readonly EventType type;
            public readonly uint? value;
            public readonly bool autoGenerated;

            public FilterEventData(EventType type, uint? value, bool autoGenerated = false)
            {
                this.type = type;
                this.value = value;
                this.autoGenerated = autoGenerated;
            }
        }

        public struct Filter
        {
            private readonly uint epsilon, deadzone;

            private LinkedList<(uint, double)> history; // value and timestamp
            private uint maxHistorySize;

            public Filter(uint epsilon, uint deadzone)
            {
                history = new LinkedList<(uint, double)>();
                maxHistorySize = 15;
                history.AddFirst((0, 0.0));

                this.epsilon = epsilon;
                this.deadzone = deadzone;
            }

            public FilterEventData PushHistory(uint rawIn, double time)
            {
                bool inDeadzone = rawIn <= deadzone;
                bool fallingToZero = history.First.Value.Item1 > deadzone && deadzone >= rawIn;
                bool jumpingFromZero = history.First.Value.Item1 <= deadzone && deadzone < rawIn;

                history.AddFirst((rawIn, time));
                if (history.Count > maxHistorySize) {
                    history.RemoveLast();
                }

                /*
                if (fallingToZero)
                {
                    StringBuilder sb = new StringBuilder("History: ");
                    foreach ((uint, double) pair in history)
                    {
                        sb.Append("(");
                        sb.Append(pair.Item2);
                        sb.Append(", ");
                        sb.Append(pair.Item1);
                        sb.Append("), ");
                    }

                    sb.Append(" inDeadZone: ");
                    sb.Append(inDeadzone);
                    sb.Append(" falling: ");
                    sb.Append(fallingToZero);
                    sb.Append(" Jumping: ");
                    sb.Append(jumpingFromZero);
                    Debug.Log(sb.ToString());

                }
                */

                if (inDeadzone) {
                    if (fallingToZero) {
                        uint? calculatedValue = CalculateLastValueBeforeRelease();
                        history.Clear();
                        history.AddFirst((0, time));
                        return new FilterEventData(EventType.FingerUp, calculatedValue);
                    }
                    else {
                        return new FilterEventData(EventType.NoTouches, rawIn);
                    }
                }
                else {
                    if (jumpingFromZero) {
                        return new FilterEventData(EventType.FingerDown, rawIn);
                    }
                    else {
                        return new FilterEventData(EventType.Touching, rawIn);
                    }
                }
            }

            public uint? CalculateLastValueBeforeRelease()
            {
                Spline2D spline = new Spline2D();
                float curT = Time.time;
                foreach((uint, double) pair in history)
                {
                    if (pair.Item1 > deadzone+epsilon)
                    {
                        spline.AddPoint(new Vector2(curT - (float)pair.Item2, (float)pair.Item1));
                    }
                }

                /*
                StringBuilder sb = new StringBuilder("Spline: ");
                for (float t = 0.0f; t <= 1.0; t += 0.05f)
                {
                    sb.Append("(");
                    Vector2 v = spline.Interpolate(t);
                    sb.Append(v.x);
                    sb.Append(", ");
                    sb.Append(v.y);
                    sb.Append("), ");
                }
                Debug.Log(sb.ToString());
                */

                float value = GradientAscent(spline);
                return (uint?)value;
            }

            private float GradientAscent(Spline2D spline)
            {
                float gamma = 0.01f;
                float precision = 0.018f;
                float curAlpha = 0.0f;
                float previousStepSize = 1.0f;
                float prevAlpha = 0.0f;

                while (previousStepSize > precision && curAlpha <= 1.0f)
                {
                    prevAlpha = curAlpha;
                    float df = spline.Derivative(prevAlpha).magnitude;
                    curAlpha += gamma * df;
                    previousStepSize = Mathf.Abs(curAlpha - prevAlpha);
                   // Debug.Log("df: " + df + " newAlpha: " + curAlpha + " prevStep: " + previousStepSize+" value: "+spline.Interpolate(prevAlpha).y);
                }
                return spline.Interpolate(prevAlpha).y;
            }

            // value is within radius epsilon of rawin
            private bool isNeighbor(uint rawin, uint? value)
                => value.HasValue && rawin - epsilon <= value && value <= rawin + epsilon;

        }
    }
}